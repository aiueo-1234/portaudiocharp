/* automatically generated by rust-bindgen 0.69.4 */

pub const paFormatIsSupported: u32 = 0;
pub const paFramesPerBufferUnspecified: u32 = 0;
extern "C" {
    #[doc = " Retrieve the release number of the currently running PortAudio build.\nFor example, for version \"19.5.1\" this will return 0x00130501.\n\n@see paMakeVersionNumber"]
    pub fn Pa_GetVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve a textual description of the current PortAudio build,\ne.g. \"PortAudio V19.5.0-devel, revision 1952M\".\nThe format of the text may change in the future. Do not try to parse the\nreturned string.\n\n@deprecated As of 19.5.0, use Pa_GetVersionInfo()->versionText instead."]
    pub fn Pa_GetVersionText() -> *const ::std::os::raw::c_char;
}
#[doc = "A structure containing PortAudio API version information.\n@see Pa_GetVersionInfo, paMakeVersionNumber\n@version Available as of 19.5.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaVersionInfo {
    pub versionMajor: ::std::os::raw::c_int,
    pub versionMinor: ::std::os::raw::c_int,
    pub versionSubMinor: ::std::os::raw::c_int,
    #[doc = "This is currently the Git revision hash but may change in the future.\nThe versionControlRevision is updated by running a script before compiling the library.\nIf the update does not occur, this value may refer to an earlier revision."]
    pub versionControlRevision: *const ::std::os::raw::c_char,
    #[doc = " Version as a string, for example \"PortAudio V19.5.0-devel, revision 1952M\""]
    pub versionText: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PaVersionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PaVersionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaVersionInfo>(),
        32usize,
        concat!("Size of: ", stringify!(PaVersionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PaVersionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PaVersionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionMajor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaVersionInfo),
            "::",
            stringify!(versionMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionMinor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PaVersionInfo),
            "::",
            stringify!(versionMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionSubMinor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaVersionInfo),
            "::",
            stringify!(versionSubMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionControlRevision) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaVersionInfo),
            "::",
            stringify!(versionControlRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionText) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PaVersionInfo),
            "::",
            stringify!(versionText)
        )
    );
}
extern "C" {
    #[doc = " Retrieve version information for the currently running PortAudio build.\n@return A pointer to an immutable PaVersionInfo structure.\n\n@note This function can be called at any time. It does not require PortAudio\nto be initialized. The structure pointed to is statically allocated. Do not\nattempt to free it or modify it.\n\n@see PaVersionInfo, paMakeVersionNumber\n@version Available as of 19.5.0."]
    pub fn Pa_GetVersionInfo() -> *const PaVersionInfo;
}
#[doc = " Error codes returned by PortAudio functions.\nNote that with the exception of paNoError, all PaErrorCodes are negative."]
pub type PaError = ::std::os::raw::c_int;
pub const PaErrorCode_paNoError: PaErrorCode = 0;
pub const PaErrorCode_paNotInitialized: PaErrorCode = -10000;
pub const PaErrorCode_paUnanticipatedHostError: PaErrorCode = -9999;
pub const PaErrorCode_paInvalidChannelCount: PaErrorCode = -9998;
pub const PaErrorCode_paInvalidSampleRate: PaErrorCode = -9997;
pub const PaErrorCode_paInvalidDevice: PaErrorCode = -9996;
pub const PaErrorCode_paInvalidFlag: PaErrorCode = -9995;
pub const PaErrorCode_paSampleFormatNotSupported: PaErrorCode = -9994;
pub const PaErrorCode_paBadIODeviceCombination: PaErrorCode = -9993;
pub const PaErrorCode_paInsufficientMemory: PaErrorCode = -9992;
pub const PaErrorCode_paBufferTooBig: PaErrorCode = -9991;
pub const PaErrorCode_paBufferTooSmall: PaErrorCode = -9990;
pub const PaErrorCode_paNullCallback: PaErrorCode = -9989;
pub const PaErrorCode_paBadStreamPtr: PaErrorCode = -9988;
pub const PaErrorCode_paTimedOut: PaErrorCode = -9987;
pub const PaErrorCode_paInternalError: PaErrorCode = -9986;
pub const PaErrorCode_paDeviceUnavailable: PaErrorCode = -9985;
pub const PaErrorCode_paIncompatibleHostApiSpecificStreamInfo: PaErrorCode = -9984;
pub const PaErrorCode_paStreamIsStopped: PaErrorCode = -9983;
pub const PaErrorCode_paStreamIsNotStopped: PaErrorCode = -9982;
pub const PaErrorCode_paInputOverflowed: PaErrorCode = -9981;
pub const PaErrorCode_paOutputUnderflowed: PaErrorCode = -9980;
pub const PaErrorCode_paHostApiNotFound: PaErrorCode = -9979;
pub const PaErrorCode_paInvalidHostApi: PaErrorCode = -9978;
pub const PaErrorCode_paCanNotReadFromACallbackStream: PaErrorCode = -9977;
pub const PaErrorCode_paCanNotWriteToACallbackStream: PaErrorCode = -9976;
pub const PaErrorCode_paCanNotReadFromAnOutputOnlyStream: PaErrorCode = -9975;
pub const PaErrorCode_paCanNotWriteToAnInputOnlyStream: PaErrorCode = -9974;
pub const PaErrorCode_paIncompatibleStreamHostApi: PaErrorCode = -9973;
pub const PaErrorCode_paBadBufferPtr: PaErrorCode = -9972;
pub const PaErrorCode_paCanNotInitializeRecursively: PaErrorCode = -9971;
pub type PaErrorCode = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Translate the supplied PortAudio error code into a human readable\nmessage."]
    pub fn Pa_GetErrorText(errorCode: PaError) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Library initialization function - call this before using PortAudio.\nThis function initializes internal data structures and prepares underlying\nhost APIs for use.  With the exception of Pa_GetVersion(), Pa_GetVersionText(),\nand Pa_GetErrorText(), this function MUST be called before using any other\nPortAudio API functions.\n\nIf Pa_Initialize() is called multiple times, each successful\ncall must be matched with a corresponding call to Pa_Terminate().\nPairs of calls to Pa_Initialize()/Pa_Terminate() may overlap, and are not\nrequired to be fully nested.\n\nNote that if Pa_Initialize() returns an error code, Pa_Terminate() should\nNOT be called.\n\n@return paNoError if successful, otherwise an error code indicating the cause\nof failure.\n\n@see Pa_Terminate"]
    pub fn Pa_Initialize() -> PaError;
}
extern "C" {
    #[doc = " Library termination function - call this when finished using PortAudio.\nThis function deallocates all resources allocated by PortAudio since it was\ninitialized by a call to Pa_Initialize(). In cases where Pa_Initialise() has\nbeen called multiple times, each call must be matched with a corresponding call\nto Pa_Terminate(). The final matching call to Pa_Terminate() will automatically\nclose any PortAudio streams that are still open.\n\nPa_Terminate() MUST be called before exiting a program which uses PortAudio.\nFailure to do so may result in serious resource leaks, such as audio devices\nnot being available until the next reboot.\n\n@return paNoError if successful, otherwise an error code indicating the cause\nof failure.\n\n@see Pa_Initialize"]
    pub fn Pa_Terminate() -> PaError;
}
#[doc = " The type used to refer to audio devices. Values of this type usually\nrange from 0 to (Pa_GetDeviceCount()-1), and may also take on the PaNoDevice\nand paUseHostApiSpecificDeviceSpecification values.\n\n@see Pa_GetDeviceCount, paNoDevice, paUseHostApiSpecificDeviceSpecification"]
pub type PaDeviceIndex = ::std::os::raw::c_int;
#[doc = " The type used to enumerate to host APIs at runtime. Values of this type\nrange from 0 to (Pa_GetHostApiCount()-1).\n\n@see Pa_GetHostApiCount"]
pub type PaHostApiIndex = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Retrieve the number of available host APIs. Even if a host API is\navailable it may have no devices available.\n\n@return A non-negative value indicating the number of available host APIs\nor, a PaErrorCode (which are always negative) if PortAudio is not initialized\nor an error is encountered.\n\n@see PaHostApiIndex"]
    pub fn Pa_GetHostApiCount() -> PaHostApiIndex;
}
extern "C" {
    #[doc = " Retrieve the index of the default host API. The default host API will be\nthe lowest common denominator host API on the current platform and is\nunlikely to provide the best performance.\n\n@return A non-negative value ranging from 0 to (Pa_GetHostApiCount()-1)\nindicating the default host API index or, a PaErrorCode (which are always\nnegative) if PortAudio is not initialized or an error is encountered."]
    pub fn Pa_GetDefaultHostApi() -> PaHostApiIndex;
}
pub const PaHostApiTypeId_paInDevelopment: PaHostApiTypeId = 0;
pub const PaHostApiTypeId_paDirectSound: PaHostApiTypeId = 1;
pub const PaHostApiTypeId_paMME: PaHostApiTypeId = 2;
pub const PaHostApiTypeId_paASIO: PaHostApiTypeId = 3;
pub const PaHostApiTypeId_paSoundManager: PaHostApiTypeId = 4;
pub const PaHostApiTypeId_paCoreAudio: PaHostApiTypeId = 5;
pub const PaHostApiTypeId_paOSS: PaHostApiTypeId = 7;
pub const PaHostApiTypeId_paALSA: PaHostApiTypeId = 8;
pub const PaHostApiTypeId_paAL: PaHostApiTypeId = 9;
pub const PaHostApiTypeId_paBeOS: PaHostApiTypeId = 10;
pub const PaHostApiTypeId_paWDMKS: PaHostApiTypeId = 11;
pub const PaHostApiTypeId_paJACK: PaHostApiTypeId = 12;
pub const PaHostApiTypeId_paWASAPI: PaHostApiTypeId = 13;
pub const PaHostApiTypeId_paAudioScienceHPI: PaHostApiTypeId = 14;
pub const PaHostApiTypeId_paAudioIO: PaHostApiTypeId = 15;
pub const PaHostApiTypeId_paPulseAudio: PaHostApiTypeId = 16;
pub const PaHostApiTypeId_paSndio: PaHostApiTypeId = 17;
#[doc = " Unchanging unique identifiers for each supported host API. This type\nis used in the PaHostApiInfo structure. The values are guaranteed to be\nunique and to never change, thus allowing code to be written that\nconditionally uses host API specific extensions.\n\nNew type ids will be allocated when support for a host API reaches\n\"public alpha\" status, prior to that developers should use the\npaInDevelopment type id.\n\n@see PaHostApiInfo"]
pub type PaHostApiTypeId = ::std::os::raw::c_uint;
#[doc = " A structure containing information about a particular host API."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaHostApiInfo {
    #[doc = " this is struct version 1"]
    pub structVersion: ::std::os::raw::c_int,
    #[doc = " The well known unique identifier of this host API @see PaHostApiTypeId"]
    pub type_: PaHostApiTypeId,
    #[doc = " A textual description of the host API for display on user interfaces."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "  The number of devices belonging to this host API. This field may be\nused in conjunction with Pa_HostApiDeviceIndexToDeviceIndex() to enumerate\nall devices for this host API.\n@see Pa_HostApiDeviceIndexToDeviceIndex"]
    pub deviceCount: ::std::os::raw::c_int,
    #[doc = " The default input device for this host API. The value will be a\ndevice index ranging from 0 to (Pa_GetDeviceCount()-1), or paNoDevice\nif no default input device is available."]
    pub defaultInputDevice: PaDeviceIndex,
    #[doc = " The default output device for this host API. The value will be a\ndevice index ranging from 0 to (Pa_GetDeviceCount()-1), or paNoDevice\nif no default output device is available."]
    pub defaultOutputDevice: PaDeviceIndex,
}
#[test]
fn bindgen_test_layout_PaHostApiInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PaHostApiInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaHostApiInfo>(),
        32usize,
        concat!("Size of: ", stringify!(PaHostApiInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PaHostApiInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PaHostApiInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostApiInfo),
            "::",
            stringify!(structVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostApiInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostApiInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostApiInfo),
            "::",
            stringify!(deviceCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultInputDevice) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostApiInfo),
            "::",
            stringify!(defaultInputDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultOutputDevice) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostApiInfo),
            "::",
            stringify!(defaultOutputDevice)
        )
    );
}
extern "C" {
    #[doc = " Retrieve a pointer to a structure containing information about a specific\nhost Api.\n\n@param hostApi A valid host API index ranging from 0 to (Pa_GetHostApiCount()-1)\n\n@return A pointer to an immutable PaHostApiInfo structure describing\na specific host API. If the hostApi parameter is out of range or an error\nis encountered, the function returns NULL.\n\nThe returned structure is owned by the PortAudio implementation and must not\nbe manipulated or freed. The pointer is only guaranteed to be valid between\ncalls to Pa_Initialize() and Pa_Terminate()."]
    pub fn Pa_GetHostApiInfo(hostApi: PaHostApiIndex) -> *const PaHostApiInfo;
}
extern "C" {
    #[doc = " Convert a static host API unique identifier, into a runtime\nhost API index.\n\n@param type A unique host API identifier belonging to the PaHostApiTypeId\nenumeration.\n\n@return A valid PaHostApiIndex ranging from 0 to (Pa_GetHostApiCount()-1) or,\na PaErrorCode (which are always negative) if PortAudio is not initialized\nor an error is encountered.\n\nThe paHostApiNotFound error code indicates that the host API specified by the\ntype parameter is not available.\n\n@see PaHostApiTypeId"]
    pub fn Pa_HostApiTypeIdToHostApiIndex(type_: PaHostApiTypeId) -> PaHostApiIndex;
}
extern "C" {
    #[doc = " Convert a host-API-specific device index to standard PortAudio device index.\nThis function may be used in conjunction with the deviceCount field of\nPaHostApiInfo to enumerate all devices for the specified host API.\n\n@param hostApi A valid host API index ranging from 0 to (Pa_GetHostApiCount()-1)\n\n@param hostApiDeviceIndex A valid per-host device index in the range\n0 to (Pa_GetHostApiInfo(hostApi)->deviceCount-1)\n\n@return A non-negative PaDeviceIndex ranging from 0 to (Pa_GetDeviceCount()-1)\nor, a PaErrorCode (which are always negative) if PortAudio is not initialized\nor an error is encountered.\n\nA paInvalidHostApi error code indicates that the host API index specified by\nthe hostApi parameter is out of range.\n\nA paInvalidDevice error code indicates that the hostApiDeviceIndex parameter\nis out of range.\n\n@see PaHostApiInfo"]
    pub fn Pa_HostApiDeviceIndexToDeviceIndex(
        hostApi: PaHostApiIndex,
        hostApiDeviceIndex: ::std::os::raw::c_int,
    ) -> PaDeviceIndex;
}
#[doc = " Structure used to return information about a host error condition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaHostErrorInfo {
    #[doc = "< the host API which returned the error code"]
    pub hostApiType: PaHostApiTypeId,
    #[doc = "< the error code returned"]
    pub errorCode: ::std::os::raw::c_long,
    #[doc = "< a textual description of the error if available, otherwise a zero-length string"]
    pub errorText: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PaHostErrorInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PaHostErrorInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaHostErrorInfo>(),
        24usize,
        concat!("Size of: ", stringify!(PaHostErrorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PaHostErrorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PaHostErrorInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostApiType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostErrorInfo),
            "::",
            stringify!(hostApiType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostErrorInfo),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorText) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaHostErrorInfo),
            "::",
            stringify!(errorText)
        )
    );
}
extern "C" {
    #[doc = " Return information about the last host error encountered. The error\ninformation returned by Pa_GetLastHostErrorInfo() will never be modified\nasynchronously by errors occurring in other PortAudio owned threads\n(such as the thread that manages the stream callback.)\n\nThis function is provided as a last resort, primarily to enhance debugging\nby providing clients with access to all available error information.\n\n@return A pointer to an immutable structure constraining information about\nthe host error. The values in this structure will only be valid if a\nPortAudio function has previously returned the paUnanticipatedHostError\nerror code."]
    pub fn Pa_GetLastHostErrorInfo() -> *const PaHostErrorInfo;
}
extern "C" {
    #[doc = " Retrieve the number of available devices. The number of available devices\nmay be zero.\n\n@return A non-negative value indicating the number of available devices or,\na PaErrorCode (which are always negative) if PortAudio is not initialized\nor an error is encountered."]
    pub fn Pa_GetDeviceCount() -> PaDeviceIndex;
}
extern "C" {
    #[doc = " Retrieve the index of the default input device. The result can be\nused in the inputDevice parameter to Pa_OpenStream().\n\n@return The default input device index for the default host API, or paNoDevice\nif no default input device is available or an error was encountered."]
    pub fn Pa_GetDefaultInputDevice() -> PaDeviceIndex;
}
extern "C" {
    #[doc = " Retrieve the index of the default output device. The result can be\nused in the outputDevice parameter to Pa_OpenStream().\n\n@return The default output device index for the default host API, or paNoDevice\nif no default output device is available or an error was encountered.\n\n@note\nOn the PC, the user can specify a default device by\nsetting an environment variable. For example, to use device #1.\n<pre>\nset PA_RECOMMENDED_OUTPUT_DEVICE=1\n</pre>\nThe user should first determine the available device ids by using\nthe supplied application \"pa_devs\"."]
    pub fn Pa_GetDefaultOutputDevice() -> PaDeviceIndex;
}
#[doc = " The type used to represent monotonic time in seconds. PaTime is\nused for the fields of the PaStreamCallbackTimeInfo argument to the\nPaStreamCallback and as the result of Pa_GetStreamTime().\n\nPaTime values have unspecified origin.\n\n@see PaStreamCallback, PaStreamCallbackTimeInfo, Pa_GetStreamTime"]
pub type PaTime = f64;
#[doc = " A type used to specify one or more sample formats. Each value indicates\na possible format for sound data passed to and from the stream callback,\nPa_ReadStream and Pa_WriteStream.\n\nThe standard formats paFloat32, paInt16, paInt32, paInt24, paInt8\nand aUInt8 are usually implemented by all implementations.\n\nThe floating point representation (paFloat32) uses +1.0 and -1.0 as the\nmaximum and minimum respectively.\n\npaUInt8 is an unsigned 8 bit format where 128 is considered \"ground\"\n\nThe paNonInterleaved flag indicates that audio data is passed as an array\nof pointers to separate buffers, one buffer for each channel. Usually,\nwhen this flag is not used, audio data is passed as a single buffer with\nall channels interleaved.\n\n@see Pa_OpenStream, Pa_OpenDefaultStream, PaDeviceInfo\n@see paFloat32, paInt16, paInt32, paInt24, paInt8\n@see paUInt8, paCustomFormat, paNonInterleaved"]
pub type PaSampleFormat = ::std::os::raw::c_ulong;
#[doc = " A structure providing information and capabilities of PortAudio devices.\nDevices may support input, output or both input and output."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaDeviceInfo {
    pub structVersion: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< note this is a host API index, not a type id"]
    pub hostApi: PaHostApiIndex,
    pub maxInputChannels: ::std::os::raw::c_int,
    pub maxOutputChannels: ::std::os::raw::c_int,
    #[doc = " Default latency values for interactive performance."]
    pub defaultLowInputLatency: PaTime,
    pub defaultLowOutputLatency: PaTime,
    #[doc = " Default latency values for robust non-interactive applications (eg. playing sound files)."]
    pub defaultHighInputLatency: PaTime,
    pub defaultHighOutputLatency: PaTime,
    pub defaultSampleRate: f64,
}
#[test]
fn bindgen_test_layout_PaDeviceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PaDeviceInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaDeviceInfo>(),
        72usize,
        concat!("Size of: ", stringify!(PaDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PaDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PaDeviceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(structVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostApi) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(hostApi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxInputChannels) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(maxInputChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxOutputChannels) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(maxOutputChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultLowInputLatency) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(defaultLowInputLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultLowOutputLatency) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(defaultLowOutputLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultHighInputLatency) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(defaultHighInputLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultHighOutputLatency) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(defaultHighOutputLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultSampleRate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PaDeviceInfo),
            "::",
            stringify!(defaultSampleRate)
        )
    );
}
extern "C" {
    #[doc = " Retrieve a pointer to a PaDeviceInfo structure containing information\nabout the specified device.\n@return A pointer to an immutable PaDeviceInfo structure. If the device\nparameter is out of range the function returns NULL.\n\n@param device A valid device index in the range 0 to (Pa_GetDeviceCount()-1)\n\n@note PortAudio manages the memory referenced by the returned pointer,\nthe client must not manipulate or free the memory. The pointer is only\nguaranteed to be valid between calls to Pa_Initialize() and Pa_Terminate().\n\n@see PaDeviceInfo, PaDeviceIndex"]
    pub fn Pa_GetDeviceInfo(device: PaDeviceIndex) -> *const PaDeviceInfo;
}
#[doc = " Parameters for one direction (input or output) of a stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaStreamParameters {
    #[doc = " A valid device index in the range 0 to (Pa_GetDeviceCount()-1)\nspecifying the device to be used or the special constant\npaUseHostApiSpecificDeviceSpecification which indicates that the actual\ndevice(s) to use are specified in hostApiSpecificStreamInfo.\nThis field must not be set to paNoDevice."]
    pub device: PaDeviceIndex,
    #[doc = " The number of channels of sound to be delivered to the\nstream callback or accessed by Pa_ReadStream() or Pa_WriteStream().\nIt can range from 1 to the value of maxInputChannels in the\nPaDeviceInfo record for the device specified by the device parameter."]
    pub channelCount: ::std::os::raw::c_int,
    #[doc = " The sample format of the buffer provided to the stream callback,\na_ReadStream() or Pa_WriteStream(). It may be any of the formats described\nby the PaSampleFormat enumeration."]
    pub sampleFormat: PaSampleFormat,
    #[doc = " The desired latency in seconds. Where practical, implementations should\nconfigure their latency based on these parameters, otherwise they may\nchoose the closest viable latency instead. Unless the suggested latency\nis greater than the absolute upper limit for the device implementations\nshould round the suggestedLatency up to the next practical value - ie to\nprovide an equal or higher latency than suggestedLatency wherever possible.\nActual latency values for an open stream may be retrieved using the\ninputLatency and outputLatency fields of the PaStreamInfo structure\nreturned by Pa_GetStreamInfo().\n@see default*Latency in PaDeviceInfo, *Latency in PaStreamInfo"]
    pub suggestedLatency: PaTime,
    #[doc = " An optional pointer to a host api specific data structure\ncontaining additional information for device setup and/or stream processing.\nhostApiSpecificStreamInfo is never required for correct operation,\nif not used it should be set to NULL."]
    pub hostApiSpecificStreamInfo: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_PaStreamParameters() {
    const UNINIT: ::std::mem::MaybeUninit<PaStreamParameters> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaStreamParameters>(),
        32usize,
        concat!("Size of: ", stringify!(PaStreamParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<PaStreamParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(PaStreamParameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamParameters),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channelCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamParameters),
            "::",
            stringify!(channelCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampleFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamParameters),
            "::",
            stringify!(sampleFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suggestedLatency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamParameters),
            "::",
            stringify!(suggestedLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostApiSpecificStreamInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamParameters),
            "::",
            stringify!(hostApiSpecificStreamInfo)
        )
    );
}
extern "C" {
    #[doc = " Determine whether it would be possible to open a stream with the specified\nparameters.\n\n@param inputParameters A structure that describes the input parameters used to\nopen a stream. The suggestedLatency field is ignored. See PaStreamParameters\nfor a description of these parameters. inputParameters must be NULL for\noutput-only streams.\n\n@param outputParameters A structure that describes the output parameters used\nto open a stream. The suggestedLatency field is ignored. See PaStreamParameters\nfor a description of these parameters. outputParameters must be NULL for\ninput-only streams.\n\n@param sampleRate The required sampleRate. For full-duplex streams it is the\nsample rate for both input and output\n\n@return Returns 0 if the format is supported, and an error code indicating why\nthe format is not supported otherwise. The constant paFormatIsSupported is\nprovided to compare with the return value for success.\n\n@see paFormatIsSupported, PaStreamParameters"]
    pub fn Pa_IsFormatSupported(
        inputParameters: *const PaStreamParameters,
        outputParameters: *const PaStreamParameters,
        sampleRate: f64,
    ) -> PaError;
}
#[doc = "A single PaStream can provide multiple channels of real-time\nstreaming audio input and output to a client application. A stream\nprovides access to audio hardware represented by one or more\nPaDevices. Depending on the underlying Host API, it may be possible\nto open multiple streams using the same device, however this behavior\nis implementation defined. Portable applications should assume that\na PaDevice may be simultaneously used by at most one PaStream.\n\nPointers to PaStream objects are passed between PortAudio functions that\noperate on streams.\n\n@see Pa_OpenStream, Pa_OpenDefaultStream, Pa_OpenDefaultStream, Pa_CloseStream,\nPa_StartStream, Pa_StopStream, Pa_AbortStream, Pa_IsStreamActive,\nPa_GetStreamTime, Pa_GetStreamCpuLoad"]
pub type PaStream = ::std::os::raw::c_void;
#[doc = " Flags used to control the behavior of a stream. They are passed as\nparameters to Pa_OpenStream or Pa_OpenDefaultStream. Multiple flags may be\nORed together.\n\n@see Pa_OpenStream, Pa_OpenDefaultStream\n@see paNoFlag, paClipOff, paDitherOff, paNeverDropInput,\npaPrimeOutputBuffersUsingStreamCallback, paPlatformSpecificFlags"]
pub type PaStreamFlags = ::std::os::raw::c_ulong;
#[doc = "Timing information for the buffers passed to the stream callback.\n\nTime values are expressed in seconds and are synchronised with the time base used by Pa_GetStreamTime() for the associated stream.\n\n@see PaStreamCallback, Pa_GetStreamTime"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaStreamCallbackTimeInfo {
    #[doc = "< The time when the first sample of the input buffer was captured at the ADC input"]
    pub inputBufferAdcTime: PaTime,
    #[doc = "< The time when the stream callback was invoked"]
    pub currentTime: PaTime,
    #[doc = "< The time when the first sample of the output buffer will output the DAC"]
    pub outputBufferDacTime: PaTime,
}
#[test]
fn bindgen_test_layout_PaStreamCallbackTimeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PaStreamCallbackTimeInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaStreamCallbackTimeInfo>(),
        24usize,
        concat!("Size of: ", stringify!(PaStreamCallbackTimeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PaStreamCallbackTimeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PaStreamCallbackTimeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBufferAdcTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamCallbackTimeInfo),
            "::",
            stringify!(inputBufferAdcTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamCallbackTimeInfo),
            "::",
            stringify!(currentTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputBufferDacTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamCallbackTimeInfo),
            "::",
            stringify!(outputBufferDacTime)
        )
    );
}
#[doc = "Flag bit constants for the statusFlags to PaStreamCallback.\n\n@see paInputUnderflow, paInputOverflow, paOutputUnderflow, paOutputOverflow,\npaPrimingOutput"]
pub type PaStreamCallbackFlags = ::std::os::raw::c_ulong;
#[doc = "< Signal that the stream should continue invoking the callback and processing audio."]
pub const PaStreamCallbackResult_paContinue: PaStreamCallbackResult = 0;
#[doc = "< Signal that the stream should stop invoking the callback and finish once all output samples have played."]
pub const PaStreamCallbackResult_paComplete: PaStreamCallbackResult = 1;
#[doc = "< Signal that the stream should stop invoking the callback and finish as soon as possible."]
pub const PaStreamCallbackResult_paAbort: PaStreamCallbackResult = 2;
#[doc = "Allowable return values for the PaStreamCallback.\n@see PaStreamCallback"]
pub type PaStreamCallbackResult = ::std::os::raw::c_uint;
#[doc = "Functions of type PaStreamCallback are implemented by PortAudio clients.\nThey consume, process or generate audio in response to requests from an\nactive PortAudio stream.\n\nWhen a stream is running, PortAudio calls the stream callback periodically.\nThe callback function is responsible for processing buffers of audio samples\npassed via the input and output parameters.\n\nThe PortAudio stream callback runs at very high or real-time priority.\nIt is required to consistently meet its time deadlines. Do not allocate\nmemory, access the file system, call library functions or call other functions\nfrom the stream callback that may block or take an unpredictable amount of\ntime to complete.\n\nIn order for a stream to maintain glitch-free operation the callback\nmust consume and return audio data faster than it is recorded and/or\nplayed. PortAudio anticipates that each callback invocation may execute for\na duration approaching the duration of frameCount audio frames at the stream\nsample rate. It is reasonable to expect to be able to utilise 70% or more of\nthe available CPU time in the PortAudio callback. However, due to buffer size\nadaption and other factors, not all host APIs are able to guarantee audio\nstability under heavy CPU load with arbitrary fixed callback buffer sizes.\nWhen high callback CPU utilisation is required the most robust behavior\ncan be achieved by using paFramesPerBufferUnspecified as the\nPa_OpenStream() framesPerBuffer parameter.\n\n@param input and @param output are either arrays of interleaved samples or;\nif non-interleaved samples were requested using the paNonInterleaved sample\nformat flag, an array of buffer pointers, one non-interleaved buffer for\neach channel.\n\nThe format, packing and number of channels used by the buffers are\ndetermined by parameters to Pa_OpenStream().\n\n@param frameCount The number of sample frames to be processed by\nthe stream callback.\n\n@param timeInfo Timestamps indicating the ADC capture time of the first sample\nin the input buffer, the DAC output time of the first sample in the output buffer\nand the time the callback was invoked.\nSee PaStreamCallbackTimeInfo and Pa_GetStreamTime()\n\n@param statusFlags Flags indicating whether input and/or output buffers\nhave been inserted or will be dropped to overcome underflow or overflow\nconditions.\n\n@param userData The value of a user supplied pointer passed to\nPa_OpenStream() intended for storing synthesis data etc.\n\n@return\nThe stream callback should return one of the values in the\n::PaStreamCallbackResult enumeration. To ensure that the callback continues\nto be called, it should return paContinue (0). Either paComplete or paAbort\ncan be returned to finish stream processing, after either of these values is\nreturned the callback will not be called again. If paAbort is returned the\nstream will finish as soon as possible. If paComplete is returned, the stream\nwill continue until all buffers generated by the callback have been played.\nThis may be useful in applications such as soundfile players where a specific\nduration of output is required. However, it is not necessary to utilize this\nmechanism as Pa_StopStream(), Pa_AbortStream() or Pa_CloseStream() can also\nbe used to stop the stream. The callback must always fill the entire output\nbuffer irrespective of its return value.\n\n@see Pa_OpenStream, Pa_OpenDefaultStream\n\n@note With the exception of Pa_GetStreamCpuLoad() it is not permissible to call\nPortAudio API functions from within the stream callback."]
pub type PaStreamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        input: *const ::std::os::raw::c_void,
        output: *mut ::std::os::raw::c_void,
        frameCount: ::std::os::raw::c_ulong,
        timeInfo: *const PaStreamCallbackTimeInfo,
        statusFlags: PaStreamCallbackFlags,
        userData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Opens a stream for either input, output or both.\n\n@param stream The address of a PaStream pointer which will receive\na pointer to the newly opened stream.\n\n@param inputParameters A structure that describes the input parameters used by\nthe opened stream. See PaStreamParameters for a description of these parameters.\ninputParameters must be NULL for output-only streams.\n\n@param outputParameters A structure that describes the output parameters used by\nthe opened stream. See PaStreamParameters for a description of these parameters.\noutputParameters must be NULL for input-only streams.\n\n@param sampleRate The desired sampleRate. For full-duplex streams it is the\nsample rate for both input and output. Note that the actual sampleRate\nmay differ very slightly from the desired rate because of hardware limitations.\nThe exact rate can be queried using Pa_GetStreamInfo(). If nothing close\nto the desired sampleRate is available then the open will fail and return an error.\n\n@param framesPerBuffer The number of frames passed to the stream callback\nfunction, or the preferred block granularity for a blocking read/write stream.\nThe special value paFramesPerBufferUnspecified (0) may be used to request that\nthe stream callback will receive an optimal (and possibly varying) number of\nframes based on host requirements and the requested latency settings.\nNote: With some host APIs, the use of non-zero framesPerBuffer for a callback\nstream may introduce an additional layer of buffering which could introduce\nadditional latency. PortAudio guarantees that the additional latency\nwill be kept to the theoretical minimum however, it is strongly recommended\nthat a non-zero framesPerBuffer value only be used when your algorithm\nrequires a fixed number of frames per stream callback.\n\n@param streamFlags Flags which modify the behavior of the streaming process.\nThis parameter may contain a combination of flags ORed together. Some flags may\nonly be relevant to certain buffer formats.\n\n@param streamCallback A pointer to a client supplied function that is responsible\nfor processing and filling input and output buffers. If this parameter is NULL\nthe stream will be opened in 'blocking read/write' mode. In blocking mode,\nthe client can receive sample data using Pa_ReadStream and write sample data\nusing Pa_WriteStream, the number of samples that may be read or written\nwithout blocking is returned by Pa_GetStreamReadAvailable and\nPa_GetStreamWriteAvailable respectively.\n\n@param userData A client supplied pointer which is passed to the stream callback\nfunction. It could for example, contain a pointer to instance data necessary\nfor processing the audio buffers. This parameter is ignored if streamCallback\nis NULL.\n\n@return\nUpon success Pa_OpenStream() returns paNoError and places a pointer to a\nvalid PaStream in the stream argument. The stream is inactive (stopped).\nIf a call to Pa_OpenStream() fails, a non-zero error code is returned (see\nPaError for possible error codes) and the value of stream is invalid.\n\n@see PaStreamParameters, PaStreamCallback, Pa_ReadStream, Pa_WriteStream,\nPa_GetStreamReadAvailable, Pa_GetStreamWriteAvailable"]
    pub fn Pa_OpenStream(
        stream: *mut *mut PaStream,
        inputParameters: *const PaStreamParameters,
        outputParameters: *const PaStreamParameters,
        sampleRate: f64,
        framesPerBuffer: ::std::os::raw::c_ulong,
        streamFlags: PaStreamFlags,
        streamCallback: PaStreamCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> PaError;
}
extern "C" {
    #[doc = " A simplified version of Pa_OpenStream() that opens the default input\nand/or output devices.\n\n@param stream The address of a PaStream pointer which will receive\na pointer to the newly opened stream.\n\n@param numInputChannels  The number of channels of sound that will be supplied\nto the stream callback or returned by Pa_ReadStream. It can range from 1 to\nthe value of maxInputChannels in the PaDeviceInfo record for the default input\ndevice. If 0 the stream is opened as an output-only stream.\n\n@param numOutputChannels The number of channels of sound to be delivered to the\nstream callback or passed to Pa_WriteStream. It can range from 1 to the value\nof maxOutputChannels in the PaDeviceInfo record for the default output device.\nIf 0 the stream is opened as an input-only stream.\n\n@param sampleFormat The sample format of both the input and output buffers\nprovided to the callback or passed to and from Pa_ReadStream and Pa_WriteStream.\nsampleFormat may be any of the formats described by the PaSampleFormat\nenumeration.\n\n@param sampleRate Same as Pa_OpenStream parameter of the same name.\n@param framesPerBuffer Same as Pa_OpenStream parameter of the same name.\n@param streamCallback Same as Pa_OpenStream parameter of the same name.\n@param userData Same as Pa_OpenStream parameter of the same name.\n\n@return As for Pa_OpenStream\n\n@see Pa_OpenStream, PaStreamCallback"]
    pub fn Pa_OpenDefaultStream(
        stream: *mut *mut PaStream,
        numInputChannels: ::std::os::raw::c_int,
        numOutputChannels: ::std::os::raw::c_int,
        sampleFormat: PaSampleFormat,
        sampleRate: f64,
        framesPerBuffer: ::std::os::raw::c_ulong,
        streamCallback: PaStreamCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> PaError;
}
extern "C" {
    #[doc = " Closes an audio stream. If the audio stream is active it\ndiscards any pending buffers as if Pa_AbortStream() had been called."]
    pub fn Pa_CloseStream(stream: *mut PaStream) -> PaError;
}
#[doc = " Functions of type PaStreamFinishedCallback are implemented by PortAudio\nclients. They can be registered with a stream using the Pa_SetStreamFinishedCallback\nfunction. Once registered they are called when the stream becomes inactive\n(ie once a call to Pa_StopStream() will not block).\nA stream will become inactive after the stream callback returns non-zero,\nor when Pa_StopStream or Pa_AbortStream is called. For a stream providing audio\noutput, if the stream callback returns paComplete, or Pa_StopStream() is called,\nthe stream finished callback will not be called until all generated sample data\nhas been played.\n\n@param userData The userData parameter supplied to Pa_OpenStream()\n\n@see Pa_SetStreamFinishedCallback"]
pub type PaStreamFinishedCallback =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Register a stream finished callback function which will be called when the\nstream becomes inactive. See the description of PaStreamFinishedCallback for\nfurther details about when the callback will be called.\n\n@param stream a pointer to a PaStream that is in the stopped state - if the\nstream is not stopped, the stream's finished callback will remain unchanged\nand an error code will be returned.\n\n@param streamFinishedCallback a pointer to a function with the same signature\nas PaStreamFinishedCallback, that will be called when the stream becomes\ninactive. Passing NULL for this parameter will un-register a previously\nregistered stream finished callback function.\n\n@return on success returns paNoError, otherwise an error code indicating the cause\nof the error.\n\n@see PaStreamFinishedCallback"]
    pub fn Pa_SetStreamFinishedCallback(
        stream: *mut PaStream,
        streamFinishedCallback: PaStreamFinishedCallback,
    ) -> PaError;
}
extern "C" {
    #[doc = " Commences audio processing."]
    pub fn Pa_StartStream(stream: *mut PaStream) -> PaError;
}
extern "C" {
    #[doc = " Terminates audio processing. It waits until all pending\naudio buffers have been played before it returns."]
    pub fn Pa_StopStream(stream: *mut PaStream) -> PaError;
}
extern "C" {
    #[doc = " Terminates audio processing promptly without necessarily waiting for\npending buffers to complete."]
    pub fn Pa_AbortStream(stream: *mut PaStream) -> PaError;
}
extern "C" {
    #[doc = " Determine whether the stream is stopped.\nA stream is considered to be stopped prior to a successful call to\nPa_StartStream and after a successful call to Pa_StopStream or Pa_AbortStream.\nIf a stream callback returns a value other than paContinue the stream is NOT\nconsidered to be stopped.\n\n@return Returns one (1) when the stream is stopped, zero (0) when\nthe stream is running or, a PaErrorCode (which are always negative) if\nPortAudio is not initialized or an error is encountered.\n\n@see Pa_StopStream, Pa_AbortStream, Pa_IsStreamActive"]
    pub fn Pa_IsStreamStopped(stream: *mut PaStream) -> PaError;
}
extern "C" {
    #[doc = " Determine whether the stream is active.\nA stream is active after a successful call to Pa_StartStream(), until it\nbecomes inactive either as a result of a call to Pa_StopStream() or\nPa_AbortStream(), or as a result of a return value other than paContinue from\nthe stream callback. In the latter case, the stream is considered inactive\nafter the last buffer has finished playing.\n\n@return Returns one (1) when the stream is active (ie playing or recording\naudio), zero (0) when not playing or, a PaErrorCode (which are always negative)\nif PortAudio is not initialized or an error is encountered.\n\n@see Pa_StopStream, Pa_AbortStream, Pa_IsStreamStopped"]
    pub fn Pa_IsStreamActive(stream: *mut PaStream) -> PaError;
}
#[doc = " A structure containing unchanging information about an open stream.\n@see Pa_GetStreamInfo"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaStreamInfo {
    #[doc = " this is struct version 1"]
    pub structVersion: ::std::os::raw::c_int,
    #[doc = " The input latency of the stream in seconds. This value provides the most\naccurate estimate of input latency available to the implementation. It may\ndiffer significantly from the suggestedLatency value passed to Pa_OpenStream().\nThe value of this field will be zero (0.) for output-only streams.\n@see PaTime"]
    pub inputLatency: PaTime,
    #[doc = " The output latency of the stream in seconds. This value provides the most\naccurate estimate of output latency available to the implementation. It may\ndiffer significantly from the suggestedLatency value passed to Pa_OpenStream().\nThe value of this field will be zero (0.) for input-only streams.\n@see PaTime"]
    pub outputLatency: PaTime,
    #[doc = " The sample rate of the stream in Hertz (samples per second). In cases\nwhere the hardware sample rate is inaccurate and PortAudio is aware of it,\nthe value of this field may be different from the sampleRate parameter\npassed to Pa_OpenStream(). If information about the actual hardware sample\nrate is not available, this field will have the same value as the sampleRate\nparameter passed to Pa_OpenStream()."]
    pub sampleRate: f64,
}
#[test]
fn bindgen_test_layout_PaStreamInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PaStreamInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaStreamInfo>(),
        32usize,
        concat!("Size of: ", stringify!(PaStreamInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PaStreamInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PaStreamInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamInfo),
            "::",
            stringify!(structVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputLatency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamInfo),
            "::",
            stringify!(inputLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputLatency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamInfo),
            "::",
            stringify!(outputLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampleRate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PaStreamInfo),
            "::",
            stringify!(sampleRate)
        )
    );
}
extern "C" {
    #[doc = " Retrieve a pointer to a PaStreamInfo structure containing information\nabout the specified stream.\n@return A pointer to an immutable PaStreamInfo structure. If the stream\nparameter is invalid, or an error is encountered, the function returns NULL.\n\n@param stream A pointer to an open stream previously created with Pa_OpenStream.\n\n@note PortAudio manages the memory referenced by the returned pointer,\nthe client must not manipulate or free the memory. The pointer is only\nguaranteed to be valid until the specified stream is closed.\n\n@see PaStreamInfo"]
    pub fn Pa_GetStreamInfo(stream: *mut PaStream) -> *const PaStreamInfo;
}
extern "C" {
    #[doc = " Returns the current time in seconds for a stream according to the same clock used\nto generate callback PaStreamCallbackTimeInfo timestamps. The time values are\nmonotonically increasing and have unspecified origin.\n\nPa_GetStreamTime returns valid time values for the entire life of the stream,\nfrom when the stream is opened until it is closed. Starting and stopping the stream\ndoes not affect the passage of time returned by Pa_GetStreamTime.\n\nThis time may be used for synchronizing other events to the audio stream, for\nexample synchronizing audio to MIDI.\n\n@return The stream's current time in seconds, or 0 if an error occurred.\n\n@see PaTime, PaStreamCallback, PaStreamCallbackTimeInfo"]
    pub fn Pa_GetStreamTime(stream: *mut PaStream) -> PaTime;
}
extern "C" {
    #[doc = " Retrieve CPU usage information for the specified stream.\nThe \"CPU Load\" is a fraction of total CPU time consumed by a callback stream's\naudio processing routines including, but not limited to the client supplied\nstream callback. This function does not work with blocking read/write streams.\n\nThis function may be called from the stream callback function or the\napplication.\n\n@return\nA floating point value, typically between 0.0 and 1.0, where 1.0 indicates\nthat the stream callback is consuming the maximum number of CPU cycles possible\nto maintain real-time operation. A value of 0.5 would imply that PortAudio and\nthe stream callback was consuming roughly 50% of the available CPU time. The\nreturn value may exceed 1.0. A value of 0.0 will always be returned for a\nblocking read/write stream, or if an error occurs."]
    pub fn Pa_GetStreamCpuLoad(stream: *mut PaStream) -> f64;
}
extern "C" {
    #[doc = " Read samples from an input stream. The function doesn't return until\nthe entire buffer has been filled - this may involve waiting for the operating\nsystem to supply the data.\n\nReading from a stream that is stopped is not currently supported. In particular,\nit is not possible to drain the read buffer by calling Pa_ReadStream after\ncalling Pa_StopStream.\n\n@param stream A pointer to an open stream previously created with Pa_OpenStream.\n\n@param buffer A pointer to a buffer of sample frames. The buffer contains\nsamples in the format specified by the inputParameters->sampleFormat field\nused to open the stream, and the number of channels specified by\ninputParameters->numChannels. If non-interleaved samples were requested using\nthe paNonInterleaved sample format flag, buffer is a pointer to the first element\nof an array of buffer pointers, one non-interleaved buffer for each channel.\n\n@param frames The number of frames to be read into buffer. This parameter\nis not constrained to a specific range, however high performance applications\nwill want to match this parameter to the framesPerBuffer parameter used\nwhen opening the stream.\n\n@return On success PaNoError will be returned, or PaInputOverflowed if input\ndata was discarded by PortAudio after the previous call and before this call."]
    pub fn Pa_ReadStream(
        stream: *mut PaStream,
        buffer: *mut ::std::os::raw::c_void,
        frames: ::std::os::raw::c_ulong,
    ) -> PaError;
}
extern "C" {
    #[doc = " Write samples to an output stream. This function doesn't return until the\nentire buffer has been written - this may involve waiting for the operating\nsystem to consume the data.\n\nWriting to a stream that is stopped is not currently supported. In particular,\nit is not possible to prefill the write buffer by calling Pa_WriteStream\nprior to calling Pa_StartStream.\n\n@param stream A pointer to an open stream previously created with Pa_OpenStream.\n\n@param buffer A pointer to a buffer of sample frames. The buffer contains\nsamples in the format specified by the outputParameters->sampleFormat field\nused to open the stream, and the number of channels specified by\noutputParameters->numChannels. If non-interleaved samples were requested using\nthe paNonInterleaved sample format flag, buffer is a pointer to the first element\nof an array of buffer pointers, one non-interleaved buffer for each channel.\n\n@param frames The number of frames to be written from buffer. This parameter\nis not constrained to a specific range, however high performance applications\nwill want to match this parameter to the framesPerBuffer parameter used\nwhen opening the stream.\n\n@return On success PaNoError will be returned, or paOutputUnderflowed if\nadditional output data was inserted after the previous call and before this\ncall."]
    pub fn Pa_WriteStream(
        stream: *mut PaStream,
        buffer: *const ::std::os::raw::c_void,
        frames: ::std::os::raw::c_ulong,
    ) -> PaError;
}
extern "C" {
    #[doc = " Retrieve the number of frames that can be read from the stream without\nwaiting.\n\nWhen the stream is stopped the return value of Pa_GetStreamReadAvailable is not\ndefined.\n\n@return Returns a non-negative value representing the maximum number of frames\nthat can be read from the stream without blocking or busy waiting or, a\nPaErrorCode (which are always negative) if PortAudio is not initialized or an\nerror is encountered."]
    pub fn Pa_GetStreamReadAvailable(stream: *mut PaStream) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Retrieve the number of frames that can be written to the stream without\nwaiting.\n\nWhen the stream is stopped the return value of Pa_GetStreamWriteAvailable is not\ndefined.\n\n@return Returns a non-negative value representing the maximum number of frames\nthat can be written to the stream without blocking or busy waiting or, a\nPaErrorCode (which are always negative) if PortAudio is not initialized or an\nerror is encountered."]
    pub fn Pa_GetStreamWriteAvailable(stream: *mut PaStream) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Retrieve the size of a given sample format in bytes.\n\n@return The size in bytes of a single sample in the specified format,\nor paSampleFormatNotSupported if the format is not supported."]
    pub fn Pa_GetSampleSize(format: PaSampleFormat) -> PaError;
}
extern "C" {
    #[doc = " Put the caller to sleep for at least 'msec' milliseconds. This function is\nprovided only as a convenience for authors of portable code (such as the tests\nand examples in the PortAudio distribution.)\n\nThe function may sleep longer than requested so don't rely on this for accurate\nmusical timing."]
    pub fn Pa_Sleep(msec: ::std::os::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaAlsaStreamInfo {
    pub size: ::std::os::raw::c_ulong,
    pub hostApiType: PaHostApiTypeId,
    pub version: ::std::os::raw::c_ulong,
    pub deviceString: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PaAlsaStreamInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PaAlsaStreamInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaAlsaStreamInfo>(),
        32usize,
        concat!("Size of: ", stringify!(PaAlsaStreamInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PaAlsaStreamInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PaAlsaStreamInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaAlsaStreamInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostApiType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaAlsaStreamInfo),
            "::",
            stringify!(hostApiType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaAlsaStreamInfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceString) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PaAlsaStreamInfo),
            "::",
            stringify!(deviceString)
        )
    );
}
extern "C" {
    #[doc = " Initialize host API specific structure, call this before setting relevant attributes."]
    pub fn PaAlsa_InitializeStreamInfo(info: *mut PaAlsaStreamInfo);
}
extern "C" {
    #[doc = " Instruct whether to enable real-time priority when starting the audio thread.\n\n If this is turned on by the stream is started, the audio callback thread will be created\n with the FIFO scheduling policy, which is suitable for realtime operation."]
    pub fn PaAlsa_EnableRealtimeScheduling(s: *mut PaStream, enable: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the ALSA-lib card index of this stream's input device."]
    pub fn PaAlsa_GetStreamInputCard(s: *mut PaStream, card: *mut ::std::os::raw::c_int)
        -> PaError;
}
extern "C" {
    #[doc = " Get the ALSA-lib card index of this stream's output device."]
    pub fn PaAlsa_GetStreamOutputCard(
        s: *mut PaStream,
        card: *mut ::std::os::raw::c_int,
    ) -> PaError;
}
extern "C" {
    #[doc = " Set the number of periods (buffer fragments) to configure devices with.\n\n By default the number of periods is 4, this is the lowest number of periods that works well on\n the author's soundcard.\n @param numPeriods The number of periods."]
    pub fn PaAlsa_SetNumPeriods(numPeriods: ::std::os::raw::c_int) -> PaError;
}
extern "C" {
    #[doc = " Set the maximum number of times to retry opening busy device (sleeping for a\n short interval inbetween)."]
    pub fn PaAlsa_SetRetriesBusy(retries: ::std::os::raw::c_int) -> PaError;
}
extern "C" {
    #[doc = " Set the path and name of ALSA library file if PortAudio is configured to load it dynamically (see\n  PA_ALSA_DYNAMIC). This setting will overwrite the default name set by PA_ALSA_PATHNAME define.\n @param pathName Full path with filename. Only filename can be used, but dlopen() will lookup default\n                 searchable directories (/usr/lib;/usr/local/lib) then."]
    pub fn PaAlsa_SetLibraryPathName(pathName: *const ::std::os::raw::c_char);
}
