/* automatically generated by rust-bindgen 0.69.4 */

#[doc = " Error codes returned by PortAudio functions.\nNote that with the exception of paNoError, all PaErrorCodes are negative."]
pub type PaError = ::std::os::raw::c_int;
pub const PaHostApiTypeId_paInDevelopment: PaHostApiTypeId = 0;
pub const PaHostApiTypeId_paDirectSound: PaHostApiTypeId = 1;
pub const PaHostApiTypeId_paMME: PaHostApiTypeId = 2;
pub const PaHostApiTypeId_paASIO: PaHostApiTypeId = 3;
pub const PaHostApiTypeId_paSoundManager: PaHostApiTypeId = 4;
pub const PaHostApiTypeId_paCoreAudio: PaHostApiTypeId = 5;
pub const PaHostApiTypeId_paOSS: PaHostApiTypeId = 7;
pub const PaHostApiTypeId_paALSA: PaHostApiTypeId = 8;
pub const PaHostApiTypeId_paAL: PaHostApiTypeId = 9;
pub const PaHostApiTypeId_paBeOS: PaHostApiTypeId = 10;
pub const PaHostApiTypeId_paWDMKS: PaHostApiTypeId = 11;
pub const PaHostApiTypeId_paJACK: PaHostApiTypeId = 12;
pub const PaHostApiTypeId_paWASAPI: PaHostApiTypeId = 13;
pub const PaHostApiTypeId_paAudioScienceHPI: PaHostApiTypeId = 14;
pub const PaHostApiTypeId_paAudioIO: PaHostApiTypeId = 15;
pub const PaHostApiTypeId_paPulseAudio: PaHostApiTypeId = 16;
pub const PaHostApiTypeId_paSndio: PaHostApiTypeId = 17;
#[doc = " Unchanging unique identifiers for each supported host API. This type\nis used in the PaHostApiInfo structure. The values are guaranteed to be\nunique and to never change, thus allowing code to be written that\nconditionally uses host API specific extensions.\n\nNew type ids will be allocated when support for a host API reaches\n\"public alpha\" status, prior to that developers should use the\npaInDevelopment type id.\n\n@see PaHostApiInfo"]
pub type PaHostApiTypeId = ::std::os::raw::c_uint;
#[doc = "A single PaStream can provide multiple channels of real-time\nstreaming audio input and output to a client application. A stream\nprovides access to audio hardware represented by one or more\nPaDevices. Depending on the underlying Host API, it may be possible\nto open multiple streams using the same device, however this behavior\nis implementation defined. Portable applications should assume that\na PaDevice may be simultaneously used by at most one PaStream.\n\nPointers to PaStream objects are passed between PortAudio functions that\noperate on streams.\n\n@see Pa_OpenStream, Pa_OpenDefaultStream, Pa_OpenDefaultStream, Pa_CloseStream,\nPa_StartStream, Pa_StopStream, Pa_AbortStream, Pa_IsStreamActive,\nPa_GetStreamTime, Pa_GetStreamCpuLoad"]
pub type PaStream = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaAlsaStreamInfo {
    pub size: ::std::os::raw::c_ulong,
    pub hostApiType: PaHostApiTypeId,
    pub version: ::std::os::raw::c_ulong,
    pub deviceString: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PaAlsaStreamInfo() {
    const UNINIT: ::std::mem::MaybeUninit<PaAlsaStreamInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PaAlsaStreamInfo>(),
        32usize,
        concat!("Size of: ", stringify!(PaAlsaStreamInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PaAlsaStreamInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PaAlsaStreamInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaAlsaStreamInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostApiType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PaAlsaStreamInfo),
            "::",
            stringify!(hostApiType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PaAlsaStreamInfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceString) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PaAlsaStreamInfo),
            "::",
            stringify!(deviceString)
        )
    );
}
extern "C" {
    #[doc = " Initialize host API specific structure, call this before setting relevant attributes."]
    pub fn PaAlsa_InitializeStreamInfo(info: *mut PaAlsaStreamInfo);
}
extern "C" {
    #[doc = " Instruct whether to enable real-time priority when starting the audio thread.\n\n If this is turned on by the stream is started, the audio callback thread will be created\n with the FIFO scheduling policy, which is suitable for realtime operation."]
    pub fn PaAlsa_EnableRealtimeScheduling(s: *mut PaStream, enable: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the ALSA-lib card index of this stream's input device."]
    pub fn PaAlsa_GetStreamInputCard(s: *mut PaStream, card: *mut ::std::os::raw::c_int)
        -> PaError;
}
extern "C" {
    #[doc = " Get the ALSA-lib card index of this stream's output device."]
    pub fn PaAlsa_GetStreamOutputCard(
        s: *mut PaStream,
        card: *mut ::std::os::raw::c_int,
    ) -> PaError;
}
extern "C" {
    #[doc = " Set the number of periods (buffer fragments) to configure devices with.\n\n By default the number of periods is 4, this is the lowest number of periods that works well on\n the author's soundcard.\n @param numPeriods The number of periods."]
    pub fn PaAlsa_SetNumPeriods(numPeriods: ::std::os::raw::c_int) -> PaError;
}
extern "C" {
    #[doc = " Set the maximum number of times to retry opening busy device (sleeping for a\n short interval inbetween)."]
    pub fn PaAlsa_SetRetriesBusy(retries: ::std::os::raw::c_int) -> PaError;
}
extern "C" {
    #[doc = " Set the path and name of ALSA library file if PortAudio is configured to load it dynamically (see\n  PA_ALSA_DYNAMIC). This setting will overwrite the default name set by PA_ALSA_PATHNAME define.\n @param pathName Full path with filename. Only filename can be used, but dlopen() will lookup default\n                 searchable directories (/usr/lib;/usr/local/lib) then."]
    pub fn PaAlsa_SetLibraryPathName(pathName: *const ::std::os::raw::c_char);
}
